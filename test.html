<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MMM-WeatherForecastGraph Test</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1/dist/chartjs-plugin-annotation.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.2.0/dist/chartjs-plugin-datalabels.min.js"></script>
  <style>
    * {
      box-sizing: border-box;
    }
    body {
      background: #000;
      color: #999;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      margin: 0;
      padding: 20px;
      min-height: 100vh;
    }
    .controls {
      margin-bottom: 20px;
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }
    .controls label {
      color: #ccc;
    }
    .controls input {
      background: #222;
      border: 1px solid #444;
      color: #fff;
      padding: 8px 12px;
      border-radius: 4px;
      width: 120px;
    }
    .controls button {
      background: #4682B4;
      border: none;
      color: #fff;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
    }
    .controls button:hover {
      background: #5a9fd4;
    }
    .status {
      color: #666;
      font-size: 14px;
      margin-left: 10px;
    }
    .status.error {
      color: #ff6347;
    }
    .status.success {
      color: #32cd32;
    }
    .weather-graph-wrapper {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin: 0 auto;
      width: 800px;
    }
    .chart-container {
      background: rgba(0, 0, 0, 0.8);
      border-radius: 5px;
      padding: 5px;
    }
    .dimmed {
      color: #666;
      font-size: 14px;
      text-align: center;
      padding: 20px;
    }
  </style>
</head>
<body>
  <div class="controls">
    <label>Latitude:</label>
    <input type="text" id="lat" value="40.7128" placeholder="e.g., 40.7128">
    <label>Longitude:</label>
    <input type="text" id="lon" value="-74.0060" placeholder="e.g., -74.0060">
    <button onclick="fetchWeatherData()">Fetch Weather</button>
    <span id="status" class="status"></span>
  </div>

  <div class="weather-graph-wrapper" id="chartWrapper">
    <div class="dimmed">Enter coordinates and click "Fetch Weather" to load data...</div>
  </div>

  <script>
    // Day name abbreviations used for midnight labels on x-axis
    const DAY_NAMES = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];

    // Configuration (matching module defaults)
    const config = {
      width: 800,
      height: 450,
      showTemperature: true,
      showFeelsLike: true,
      showWind: true,
      showPrecipitation: true,
      showGridLines: true,
      animateCharts: true,
      hoursToShow: 48,
      temperatureColor: "#FFA500",
      feelsLikeColor: "#FF6347",
      windColor: "#4682B4",
      gustColor: "#6BA3D6",
      precipitationColor: "#00CED1",
      precipitationAmountColor: "#1E90FF",
      snowAmountColor: "#87CEEB"
    };

    // Store raw precipitation periods for spanning bars
    let precipitationPeriods = [];

    let charts = {};

    function setStatus(message, type = '') {
      const status = document.getElementById('status');
      status.textContent = message;
      status.className = 'status ' + type;
    }

    async function fetchWeatherData() {
      const lat = document.getElementById('lat').value.trim();
      const lon = document.getElementById('lon').value.trim();

      if (!lat || !lon) {
        setStatus('Please enter latitude and longitude', 'error');
        return;
      }

      // Validate coordinate values
      const latNum = Number(lat);
      const lonNum = Number(lon);
      if (!Number.isFinite(latNum) || !Number.isFinite(lonNum) ||
          latNum < -90 || latNum > 90 || lonNum < -180 || lonNum > 180) {
        setStatus('Invalid coordinates. Latitude: -90 to 90, Longitude: -180 to 180', 'error');
        return;
      }

      setStatus('Fetching location data...');

      try {
        // Step 1: Get grid coordinates from points endpoint
        const pointsUrl = `https://api.weather.gov/points/${lat},${lon}`;
        const pointsResponse = await fetch(pointsUrl, {
          headers: { 'User-Agent': 'MMM-WeatherForecastGraph-Test' }
        });

        if (!pointsResponse.ok) {
          throw new Error(`Points API error: ${pointsResponse.status}`);
        }

        const pointsData = await pointsResponse.json();
        const forecastGridDataUrl = pointsData.properties.forecastGridData;

        setStatus('Fetching hourly forecast...');

        // Step 2: Get hourly forecast data
        const gridResponse = await fetch(forecastGridDataUrl, {
          headers: { 'User-Agent': 'MMM-WeatherForecastGraph-Test' }
        });

        if (!gridResponse.ok) {
          throw new Error(`Grid API error: ${gridResponse.status}`);
        }

        const gridData = await gridResponse.json();

        // Process the data into hourly format
        const hourlyData = processWeatherGovData(gridData.properties);

        setStatus(`Loaded ${hourlyData.length} hours of data`, 'success');

        // Render charts
        renderCharts(hourlyData);

      } catch (error) {
        console.error('Error fetching weather:', error);
        setStatus(`Error: ${error.message}`, 'error');
      }
    }

    function processWeatherGovData(properties) {
      // Get the next 48 hours of data
      const now = new Date();
      const hourlyData = [];

      // Weather.gov returns data as time series with validTime ranges
      // We need to expand these into hourly points

      const tempValues = expandTimeSeries(properties.temperature?.values || []);
      const feelsLikeValues = expandTimeSeries(properties.apparentTemperature?.values || []);
      const windSpeedValues = expandTimeSeries(properties.windSpeed?.values || []);
      const windGustValues = expandTimeSeries(properties.windGust?.values || []);
      const popValues = expandTimeSeries(properties.probabilityOfPrecipitation?.values || []);

      // Find the starting hour (current hour)
      const startHour = new Date(now);
      startHour.setMinutes(0, 0, 0);

      // Build hourly data first (we need temps for precipitation filtering)
      for (let i = 0; i < config.hoursToShow; i++) {
        const targetTime = new Date(startHour.getTime() + i * 3600000);

        // Find values for this hour
        const temp = findValueAtTime(tempValues, targetTime);
        const feelsLike = findValueAtTime(feelsLikeValues, targetTime);
        const windSpeed = findValueAtTime(windSpeedValues, targetTime);
        const windGust = findValueAtTime(windGustValues, targetTime);
        const pop = findValueAtTime(popValues, targetTime);

        hourlyData.push({
          dt: Math.floor(targetTime.getTime() / 1000),
          temp: celsiusToFahrenheit(temp),
          feels_like: celsiusToFahrenheit(feelsLike),
          wind_speed: kphToMph(windSpeed),
          wind_gust: kphToMph(windGust),
          pop: pop !== null ? pop / 100 : 0  // Convert to 0-1 range
        });
      }

      // Extract rain and snow periods separately, then merge preferring snow
      // Pass hourly data to filter out rain when it's freezing
      const rainPeriods = extractPrecipitationPeriods(
        properties.quantitativePrecipitation?.values || [],
        now,
        "rain"
      );
      const snowPeriods = extractPrecipitationPeriods(
        properties.snowfallAmount?.values || [],
        now,
        "snow"
      );
      precipitationPeriods = mergePrecipitationPeriods(rainPeriods, snowPeriods, hourlyData);

      return hourlyData;
    }

    function expandTimeSeries(values) {
      // Weather.gov uses ISO 8601 duration format: "2024-01-01T00:00:00+00:00/PT1H"
      const expanded = [];

      for (const item of values) {
        if (!item.validTime) continue;

        const [startStr, durationStr] = item.validTime.split('/');
        const startTime = new Date(startStr);
        const hours = parseDuration(durationStr);

        for (let h = 0; h < hours; h++) {
          const time = new Date(startTime.getTime() + h * 3600000);
          expanded.push({
            time: time,
            value: item.value
          });
        }
      }

      return expanded;
    }

    // Parse ISO 8601 duration - only supports hours format (e.g., "PT1H", "PT6H")
    // Other duration formats will default to 1 hour
    function parseDuration(duration) {
      const match = duration.match(/PT(\d+)H/);
      return match ? parseInt(match[1], 10) : 1;
    }

    function findValueAtTime(expandedValues, targetTime) {
      // Find the value that covers the target time
      for (const item of expandedValues) {
        if (item.time.getTime() <= targetTime.getTime() &&
            targetTime.getTime() < item.time.getTime() + 3600000) {
          return item.value;
        }
      }
      // If not found, find closest before
      let closest = null;
      for (const item of expandedValues) {
        if (item.time.getTime() <= targetTime.getTime()) {
          closest = item.value;
        }
      }
      return closest;
    }

    function celsiusToFahrenheit(celsius) {
      if (celsius === null || celsius === undefined) return null;
      return Math.round((celsius * 9/5) + 32);
    }

    function kphToMph(kph) {
      if (kph === null || kph === undefined) return null;
      return Math.round(kph * 0.621371);
    }

    function mmToInches(mm) {
      if (mm === null || mm === undefined) return null;
      return Math.round(mm * 0.0393701 * 100) / 100;  // 2 decimal places
    }

    function extractPrecipitationPeriods(values, now, type = "rain") {
      // Extract precipitation periods that fall within our display window
      const periods = [];
      const startHour = new Date(now);
      startHour.setMinutes(0, 0, 0);
      const endTime = new Date(startHour.getTime() + config.hoursToShow * 3600000);

      for (const item of values) {
        if (!item.validTime || item.value === 0) continue;

        const [startStr, durationStr] = item.validTime.split('/');
        const periodStart = new Date(startStr);
        const hours = parseDuration(durationStr);
        const periodEnd = new Date(periodStart.getTime() + hours * 3600000);

        // Check if this period overlaps with our display window
        if (periodEnd <= startHour || periodStart >= endTime) continue;

        // Clip to our display window
        const displayStart = new Date(Math.max(periodStart.getTime(), startHour.getTime()));
        const displayEnd = new Date(Math.min(periodEnd.getTime(), endTime.getTime()));

        // Calculate hour indices for the chart
        const startIndex = Math.floor((displayStart.getTime() - startHour.getTime()) / 3600000);
        const endIndex = Math.floor((displayEnd.getTime() - startHour.getTime()) / 3600000);

        const amount = mmToInches(item.value);
        // Different thresholds for rain vs snow
        const displayThreshold = type === "snow" ? 0.1 : 0.01;

        periods.push({
          startIndex,
          endIndex,
          startTime: displayStart,
          endTime: displayEnd,
          amount_mm: item.value,
          amount: amount,
          displayThreshold: displayThreshold,
          type: type
        });
      }

      return periods;
    }

    // Merge rain and snow periods, preferring snow when they overlap
    // Also hides rain when temp is at or below freezing (misleading to show rain at 28°F)
    function mergePrecipitationPeriods(rainPeriods, snowPeriods, hourlyData) {
      const snowByStart = new Map();
      snowPeriods.forEach(p => snowByStart.set(p.startIndex, p));

      const merged = [];
      const usedSnowIndices = new Set();

      // Freezing threshold: 32°F (test.html always uses imperial)
      const freezingPoint = 32;

      rainPeriods.forEach(rain => {
        const snow = snowByStart.get(rain.startIndex);
        if (snow && snow.amount > 0) {
          merged.push(snow);  // Prefer snow (what users care about)
          usedSnowIndices.add(rain.startIndex);
        } else if (rain.amount > 0) {
          // Check temperature at this hour - skip rain if it's freezing
          const temp = hourlyData[rain.startIndex]?.temp;
          const isFreezing = temp !== null && temp !== undefined && temp <= freezingPoint;

          if (!isFreezing) {
            merged.push(rain);  // Only show rain if above freezing
          }
          // Below freezing with no snow data: skip (don't show misleading rain)
        }
      });

      snowPeriods.forEach(snow => {
        if (!usedSnowIndices.has(snow.startIndex) && snow.amount > 0) {
          merged.push(snow);
        }
      });

      return merged;
    }

    function calculateChartHeight() {
      let visibleCharts = 0;
      if (config.showTemperature) visibleCharts++;
      if (config.showWind) visibleCharts++;
      if (config.showPrecipitation) visibleCharts++;
      return visibleCharts > 0 ? Math.floor(config.height / visibleCharts) : config.height;
    }

    function destroyAllCharts() {
      Object.keys(charts).forEach(key => {
        if (charts[key]) {
          charts[key].destroy();
          charts[key] = null;
        }
      });
    }

    function formatHour(timestamp) {
      if (timestamp == null || isNaN(timestamp)) return "--";
      const date = new Date(timestamp * 1000);
      if (isNaN(date.getTime())) return "--";
      const hour = date.getHours();
      // Show weekday abbreviation at midnight as day marker
      if (hour === 0) {
        return DAY_NAMES[date.getDay()];
      }
      const ampm = hour >= 12 ? "p" : "a";
      const hour12 = hour % 12 || 12;
      return hour12 + ampm;
    }

    function getMidnightIndices(hourlyData) {
      const indices = [];
      hourlyData.forEach((h, idx) => {
        const date = new Date(h.dt * 1000);
        if (date.getHours() === 0) {
          indices.push(idx);
        }
      });
      return indices;
    }

    function getMidnightAnnotations(hourlyData) {
      const annotations = {};
      getMidnightIndices(hourlyData).forEach((idx, i) => {
        annotations["midnight" + i] = {
          type: "line",
          xMin: idx,
          xMax: idx,
          borderColor: "#555",
          borderWidth: 1,
          borderDash: [4, 4]
        };
      });
      return annotations;
    }

    function getChartOptions(title) {
      return {
        responsive: false,
        maintainAspectRatio: false,
        animation: config.animateCharts ? {} : false,
        plugins: {
          legend: {
            display: (title === "Temperature" && config.showFeelsLike) || title === "Wind",
            position: "right",
            labels: {
              color: "#999",
              font: { size: 12 },
              boxWidth: 20,
              padding: 5
            }
          },
          title: {
            display: true,
            text: title,
            color: "#999",
            font: { size: 14 }
          }
        },
        scales: {
          x: {
            offset: true,  // Add space between y-axis and first data point
            grid: {
              display: config.showGridLines,
              color: "#333"
            },
            ticks: {
              color: "#999",
              font: { size: 12 },
              autoSkip: false,
              maxRotation: 0,
              callback: function(value, index) {
                const label = this.getLabelForValue(value);
                // Check if this is a day name using exact array match (not character detection)
                const isDayLabel = DAY_NAMES.includes(label);
                // At midnight, show day name on second line (first line blank)
                if (isDayLabel) {
                  return ["", label];
                }
                // Show regular hours every 4 hours
                if (index % 4 === 0) {
                  return label;
                }
                return null;
              }
            }
          },
          y: {
            afterFit: function(scaleInstance) {
              scaleInstance.width = 45;  // Fixed width to align all charts
            },
            grid: {
              display: config.showGridLines,
              color: "#333"
            },
            ticks: {
              color: "#999",
              font: { size: 12 }
            },
            grace: '5%'
          }
        }
      };
    }

    // Plugin to force fixed legend width for chart alignment
    const legendFixedWidthPlugin = {
      id: "legendFixedWidth",
      beforeInit: function (chart) {
        if (!chart.legend) return;
        const originalFit = chart.legend.fit;
        chart.legend.fit = function () {
          originalFit.call(this);
          this.width = 120; // Fixed width for all legends
        };
      }
    };

    function renderCharts(hourlyData) {
      // Register plugins if not already registered
      if (typeof ChartDataLabels !== 'undefined' && !Chart.registry.plugins.get('datalabels')) {
        Chart.register(ChartDataLabels);
      }
      if (!Chart.registry.plugins.get('legendFixedWidth')) {
        Chart.register(legendFixedWidthPlugin);
      }

      destroyAllCharts();

      const wrapper = document.getElementById('chartWrapper');
      wrapper.innerHTML = '';

      const chartHeight = calculateChartHeight();
      const labels = hourlyData.map(h => formatHour(h.dt));

      if (config.showTemperature) {
        const container = document.createElement('div');
        container.className = 'chart-container';
        const canvas = document.createElement('canvas');
        canvas.id = 'temp-chart';
        canvas.width = config.width;
        canvas.height = chartHeight;
        container.appendChild(canvas);
        wrapper.appendChild(container);

        const datasets = [
          {
            label: "Temperature",
            data: hourlyData.map(h => h.temp),
            borderColor: config.temperatureColor,
            backgroundColor: "transparent",
            tension: 0.3,
            fill: false,
            pointRadius: 0,
            borderWidth: 2
          }
        ];

        if (config.showFeelsLike) {
          datasets.push({
            label: "Feels Like",
            data: hourlyData.map(h => h.feels_like),
            borderColor: config.feelsLikeColor,
            backgroundColor: "transparent",
            tension: 0.3,
            fill: false,
            pointRadius: 0,
            borderWidth: 2,
            borderDash: [5, 5]
          });
        }

        const tempOptions = getChartOptions("Temperature");
        tempOptions.plugins.datalabels = {
          display: function(context) {
            // Show label every 4 hours, only for Temperature (not Feels Like)
            return context.dataIndex % 4 === 0 && context.datasetIndex === 0;
          },
          color: '#ccc',
          textStrokeColor: 'rgba(0,0,0,0.8)',
          textStrokeWidth: 3,
          anchor: 'end',
          align: 'top',
          offset: 2,
          font: { size: 11 },
          formatter: function(value) {
            return value !== null ? Math.round(value) + '°' : '';
          }
        };
        // Add midnight vertical line annotations
        tempOptions.plugins.annotation = {
          annotations: getMidnightAnnotations(hourlyData)
        };

        charts.temp = new Chart(canvas, {
          type: "line",
          data: { labels, datasets },
          options: tempOptions
        });
      }

      if (config.showWind) {
        const container = document.createElement('div');
        container.className = 'chart-container';
        const canvas = document.createElement('canvas');
        canvas.id = 'wind-chart';
        canvas.width = config.width;
        canvas.height = chartHeight;
        container.appendChild(canvas);
        wrapper.appendChild(container);

        const windOptions = getChartOptions("Wind");
        windOptions.plugins.datalabels = {
          display: function(context) {
            return context.dataIndex % 4 === 0 && context.datasetIndex === 0;
          },
          color: '#ccc',
          textStrokeColor: 'rgba(0,0,0,0.8)',
          textStrokeWidth: 3,
          anchor: 'end',
          align: 'top',
          offset: 2,
          font: { size: 11 },
          formatter: function(value) {
            return value !== null ? Math.round(value) : '';
          }
        };
        // Add midnight vertical line annotations
        windOptions.plugins.annotation = {
          annotations: getMidnightAnnotations(hourlyData)
        };

        charts.wind = new Chart(canvas, {
          type: "line",
          data: {
            labels,
            datasets: [
              {
                label: "Wind Speed",
                data: hourlyData.map(h => h.wind_speed),
                borderColor: config.windColor,
                backgroundColor: "transparent",
                tension: 0.3,
                fill: false,
                pointRadius: 0,
                borderWidth: 2
              },
              {
                label: "Wind Gust",
                data: hourlyData.map(h => h.wind_gust || null),
                borderColor: config.gustColor,
                backgroundColor: "transparent",
                tension: 0.3,
                fill: false,
                pointRadius: 0,
                borderWidth: 2,
                borderDash: [5, 5]
              }
            ]
          },
          options: windOptions
        });
      }

      if (config.showPrecipitation) {
        const container = document.createElement('div');
        container.className = 'chart-container';
        const canvas = document.createElement('canvas');
        canvas.id = 'precip-chart';
        canvas.width = config.width;
        canvas.height = chartHeight;
        container.appendChild(canvas);
        wrapper.appendChild(container);

        // Build annotations: midnight lines + precipitation amount boxes
        const annotations = getMidnightAnnotations(hourlyData);
        // Fixed height for all precipitation boxes - label shows the amount
        const fixedHeight = 30;

        precipitationPeriods.forEach((period, idx) => {
          // Only show box if amount is above display threshold
          if (period.amount < period.displayThreshold) return;

          // Skip boxes at chart start (index 0) with less than 2 hours visible
          // Future 1-hour windows are fine, only skip partial windows at the leading edge
          if (period.startIndex === 0 && period.endIndex - period.startIndex < 2) return;

          // Use different colors for rain vs snow
          const isSnow = period.type === "snow";
          const boxColor = isSnow ? config.snowAmountColor : config.precipitationAmountColor;

          annotations[`precip${idx}`] = {
            type: 'box',
            xMin: period.startIndex - 0.5,
            xMax: period.endIndex - 0.5,
            yMin: 0,
            yMax: fixedHeight,
            backgroundColor: boxColor + '66',  // 40% opacity
            borderColor: boxColor,
            borderWidth: 1,
            label: {
              display: true,
              content: period.amount.toFixed(2) + '"',
              color: '#ccc',
              textStrokeColor: 'rgba(0,0,0,0.8)',
              textStrokeWidth: 3,
              font: { size: 11, weight: 'normal' },
              position: 'center'
            }
          };
        });

        const baseOptions = getChartOptions("Precipitation");
        charts.precip = new Chart(canvas, {
          type: "bar",
          data: {
            labels,
            datasets: [
              {
                label: "Chance %",
                data: hourlyData.map(h => (h.pop || 0) * 100),
                backgroundColor: config.precipitationColor + '99',  // 60% opacity
                borderWidth: 0,
                barPercentage: 0.8,
                categoryPercentage: 0.9
              }
            ]
          },
          options: {
            ...baseOptions,
            clip: false,  // Allow bars/annotations to render outside chart area
            plugins: {
              ...baseOptions.plugins,
              datalabels: { display: false },
              legend: {
                display: true,
                position: "right",
                labels: {
                  color: "#999",
                  font: { size: 12 },
                  boxWidth: 20,
                  padding: 5,
                  generateLabels: function(chart) {
                    const original = Chart.defaults.plugins.legend.labels.generateLabels(chart);
                    // Add custom legend entries for rain and snow amounts
                    const hasRain = precipitationPeriods.some(p => p.type === "rain");
                    const hasSnow = precipitationPeriods.some(p => p.type === "snow");

                    if (hasRain) {
                      original.push({
                        text: 'Rain',
                        fillStyle: config.precipitationAmountColor + '66',
                        strokeStyle: config.precipitationAmountColor,
                        lineWidth: 1,
                        hidden: false
                      });
                    }
                    if (hasSnow) {
                      original.push({
                        text: 'Snow',
                        fillStyle: config.snowAmountColor + '66',
                        strokeStyle: config.snowAmountColor,
                        lineWidth: 1,
                        hidden: false
                      });
                    }
                    return original;
                  }
                }
              },
              annotation: {
                annotations: annotations
              }
            },
            scales: {
              ...baseOptions.scales,
              x: {
                ...baseOptions.scales.x,
                grid: {
                  ...baseOptions.scales.x.grid,
                  offset: false
                }
              },
              y: {
                ...baseOptions.scales.y,
                min: 0,
                max: 100
              }
            }
          }
        });
      }
    }

    // Auto-load on page load with default coordinates
    window.addEventListener('load', () => {
      fetchWeatherData();
    });
  </script>
</body>
</html>
